
"""
# Return a subspace shadow generated
# by Schmidt-decomposing state k at site p:
function OneStateSiteDecomposition(sdata, U_k, sigma_k, V_k, H_list, S_list, p, k)
    
    M = sdata.mparams.M
    tol = sdata.mparams.psi_tol
    m = sdata.mparams.psi_maxdim
    
    psi_decomp = []
    vec = []
        
    sigma = diag(Array(sigma_k.tensor))
        
    m_eff = length(sigma)
        
    ids = inds(H_diag[j], plev=0)
        
    for j=1:m_eff
            
        S_jk = ITensor(zeros((dim(ids[1]),dim(ids[2]))),ids[1],ids[2])
            
        S_jk[ids[1]=>j,ids[2]=>j] = 1.0

        push!(psi_decomp, S_jk)
            
    end
        
    vec = sigma
    
    M_gm = sdata.mparams.M
    M_tot = M_gm+m_eff-1
    
    H_full = zeros((M_tot,M_tot))
    S_full = zeros((M_tot,M_tot))
    
    k0 = k
    k1 = k+m_eff-1
    
    # Existing blocks:
    H_full[1:k0-1,1:k0-1] = sdata.H_mat[1:k-1,1:k-1]
    H_full[k1+1:M_tot,k1+1:M_tot] = sdata.H_mat[k+1:M,k+1:M]
    H_full[1:k0-1,k1+1:M_tot] = sdata.H_mat[1:k-1,k+1:M]
    H_full[k1+1:M_tot,1:k0-1] = sdata.H_mat[k+1:M,1:k-1]
    
    S_full[1:k0-1,1:k0-1] = sdata.S_mat[1:k-1,1:k-1]
    S_full[k1+1:M_tot,(k+m_eff-1):M_tot] = sdata.S_mat[k+1:M,k+1:M]
    S_full[1:k0-1,k1+1:M_tot] = sdata.S_mat[1:k-1,k+1:M]
    S_full[k1+1:M_tot,1:k0-1] = sdata.S_mat[k+1:M,1:k-1]
    
    # The middle block:
    H_block = zeros((m_eff,m_eff))
        
    for i=k0:k1, j=k0:k1
        H_block[i,j] = scalar( psi_decomp[i-k0+1] * dag(H_list[k]) * setprime(dag(psi_decomp[j-k0+1]),1) )
        H_block[j,i] = H_block[i,j]
    end
        
    H_full[k0:k1,k0:k1] = deepcopy(H_block)
    S_full[k0:k1,k0:k1] = Matrix(I, m_eff, m_eff)
    
    # Off-diagonal blocks:
    H_block = zeros((k-1,m_eff))
    S_block = zeros((k-1,m_eff))
    for i=1:k0-1, j=k0:k1
        
        H_block[i,j] = scalar( psi_decomp_j[l] * dag(H_offdiag[i][j-i]) * setprime(dag(psi_decomp_i[k]),1) )
        S_block[k,l] = scalar( psi_decomp_j[l] * dag(S_offdiag[i][j-i]) * setprime(dag(psi_decomp_i[k]),1) )
            
        H_full[i0:i1,j0:j1] = H_block
        H_full[j0:j1,i0:i1] = transpose(H_block)
        
        S_full[i0:i1,j0:j1] = S_block
        S_full[j0:j1,i0:i1] = transpose(S_block)
        
    end
    
    # Construct the "subspace shadow" object:
    shadow = SubspaceShadow(
        sdata.chem_data,
        M_list,
        sdata.mparams.thresh,
        sdata.mparams.eps,
        vec_list,
        [],
        H_full,
        S_full,
        zeros((M_gm,M_gm)),
        zeros((M_gm,M_gm)),
        zeros(M_gm),
        zeros((M_gm,M_gm)),
        0.0
    )
    
    GenSubspaceMats!(shadow)
    
    SolveGenEig!(shadow)
    
    return shadow
    
end
"""

"""
function OneStateTopBlocks(sdata::SubspaceProperties, k)
    
    n = sdata.chem_data.N_spt
    M = sdata.mparams.M

    H_top = Any[1.0 for j=1:M]
    S_top = Any[1.0 for j=1:M]
    
    # Initialize the lists:
    H_top_list = [deepcopy(H_top)]
    S_top_list = [deepcopy(S_top)]
    
    # Update the top blocks and push to list:
    for p=n:(-1):3
        
        for j=1:M
            
            if j==k
                H_top[j] *= sdata.psi_list[j][p] * sdata.ham_list[j][p] * setprime(dag(sdata.psi_list[j][p]),1)
            else
                yP = sdata.psi_list[j][p] * setprime(sdata.perm_ops[k][j-k][p],2,plev=1)
                Hx = setprime(sdata.ham_list[k][p],2,plev=0) * setprime(dag(sdata.psi_list[k][p]),1)

                H_top[j] *= yP
                H_top[j] *= Hx

                S_top[j] *= sdata.psi_list[j][p] * sdata.perm_ops[k][j-k][p] * setprime(dag(sdata.psi_list[k][p]),1)
            end

        end
        
        push!(H_top_list, deepcopy(H_top))
        push!(S_top_list, deepcopy(S_top))

    end
    
    return reverse(H_top_list), reverse(S_top_list)
    
end
"""

"""
function OneStateUpdateBlocks!(sdata, p, Q, H_list, S_list, k)
    
    M = sdata.mparams.M
    
    for j=1:M
        
        if j==k
            H_list[j] *= Q * sdata.ham_list[j][p] * setprime(dag(Q),1)
        else

            yP = sdata.psi_list[j][p] * setprime(sdata.perm_ops[k][j-k][p],2,plev=1)
            Hx = setprime(sdata.ham_list[k][p],2,plev=0) * setprime(dag(Q),1)

            H_list[j] *= yP
            H_list[j] *= Hx

            S_list[j] *= sdata.psi_list[j][p] * sdata.perm_ops[k][j-k][p] * setprime(dag(Q),1)

        end

    end
    
end
"""


"""
function SingleGeomOptim!(
        sdata::SubspaceProperties; 
        sweeps=1,
        maxiter=1000,
        method="bboptim",
        delta=1e-2,
        alpha=1e2,
        stun=true,
        gamma=1.0,
        noise=[0.0],
        thresh="projection",
        eps=1e-12,
        restrict_svals=false,
        verbose=false
    )
    
    M = sdata.mparams.M
    
    n = sdata.chem_data.N_spt
    
    E_min = sdata.E[1]
    kappa = sdata.kappa
    
    # The sweep loop:
    for l=1:loops
        
        # Sweep noise parameter:
        if l > length(noise)
            eps = noise[end]
        else
            eps = noise[l]
        end
        
        # Optimize state k:
        for k=1:sdata.mparams.M
            
            for s=1:sweeps
                
                # Right-orthogonalize all vectors:
                for j=1:M
                    #truncate!(sdata.psi_list[j], cutoff=1e-12, min_blockdim=3, maxdim=3)
                    orthogonalize!(sdata.psi_list[j],1)
                end
                
                # Pre-contract the "top" blocks prior to sweep:
                H_top_list, S_top_list = OneStateTopBlocks(sdata, k)

                # Initialize the "bottom" blocks:
                H_bot = Any[1.0 for i=1:M]
                S_bot = Any[1.0 for i=1:M]

                # The site loop:
                for p=1:n-1

                    # Select the correct "top" blocks:
                    H_top = H_top_list[p]
                    S_top = S_top_list[p]

                    # Decompose state k at p:
                    U,S,V = SiteSVD(sdata.psi_list[k],p, restrict_svals=restrict_svals)

                    # Make a copy for later:
                    H_bot_copy = deepcopy(H_bot)
                    S_bot_copy = deepcopy(S_bot)

                    # contract the final layer of each block:
                    OneStateUpdateBlocks!(sdata, p, U, H_bot, S_bot, k)
                    OneStateUpdateBlocks!(sdata, p+1, V, H_top, S_top, k)
        
                    # Pre-contract the block tensors for obtaining the H and S matrix elements:
                    H_list = [H_top[j]*H_bot[j] for j=1:M]
                    S_list = [S_top[j]*S_bot[j] for j=1:M]

                    # Generate the state decompositions \\
                    # ...and store as a subspace shadow object:
                    shadow = SiteDecomposition(sdata, U, sigma, V, H_list, S_list, p)

                    M_tot = sum(shadow.M_list)

                    c0 = zeros(M_tot)

                    for j=1:length(shadow.M_list)
                        j0 = sum(shadow.M_list[1:j-1])+1
                        j1 = sum(shadow.M_list[1:j])
                        c0[j0:j1] = shadow.vec_list[j]
                    end

                    shadow_copy = copy(shadow)

                    if method=="annealing"

                        # Simulated annealing:
                        MultiGeomAnneal!(shadow, c0, maxiter, alpha=alpha, delta=delta, gamma=gamma, stun=stun)

                    elseif method=="bboptim"

                        # Black-box optimizer:
                        MultiGeomBB!(shadow, c0, maxiter)

                    elseif method=="geneig"

                        # Full diagonalization:
                        MultiGeomGenEig!(shadow, thresh, eps)

                    end

                    # Replace the state tensors:
                    ReplaceStates!(sdata, U_list, sigma_list, V_list, p, shadow.vec_list, eps)

                    GenSubspaceMats!(shadow)
                    SolveGenEig!(shadow)
                    E_min = shadow.E[1]
                    kappa = shadow.kappa 

                    # Update the bottom blocks:
                    new_U_list = [sdata.psi_list[j][p] for j=1:M]
                    UpdateBlocks!(sdata, p, new_U_list, H_bot_diag_copy, H_bot_offdiag_copy, S_bot_offdiag_copy)

                    H_bot_diag = H_bot_diag_copy
                    H_bot_offdiag = H_bot_offdiag_copy
                    S_bot_offdiag = S_bot_offdiag_copy

                    if verbose
                        print("Sweep: [$(s)/$(sweeps)]; site: [$(p)/$(sdata.chem_data.N_spt-1)]; E_min = $(E_min); kappa = $(kappa)             \r")
                        flush(stdout)
                    end

                    # Free up some memory:
                    #H_top_diag_list[p] = [nothing]
                    #H_top_offdiag_list[p] = [[nothing]]
                    #S_top_offdiag_list[p] = [[nothing]]

                end

                # After each sweep, truncate back to the max bond dim:
                for j=1:M
                    truncate!(sdata.psi_list[j], maxdim=sdata.mparams.psi_maxdim)
                    normalize!(sdata.psi_list[j])
                end

            end
            
        end
        
    end
    
end
"""